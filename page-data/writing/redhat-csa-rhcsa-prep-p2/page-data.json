{"componentChunkName":"component---src-templates-blog-template-js","path":"/writing/redhat-csa-rhcsa-prep-p2","webpackCompilationHash":"390bcefcb0a5d69758ed","result":{"data":{"markdownRemark":{"html":"<p><strong>Keywords: rhsca, preparation, exam, linux, system administrator</strong></p>\n<p>This is part two of my <a href=\"https://www.redhat.com/en/services/training/ex200-red-hat-certified-system-administrator-rhcsa-exam\">RHCSA</a> preparation series.   In this part, we'll cover the\nfirst exam objective: </p>\n<ul>\n<li>Understand and use essential tools for handling files, directories,\ncommandline environments, and documentation. <em>Essential tools</em></li>\n</ul>\n<h1>Essential tools</h1>\n<p>I imagine this is the simplest exam topic that probably won't need anything more\nthan a 10 minute refresher.</p>\n<p>From the guidelines, we'll cover:</p>\n<ul>\n<li>[ET.1] Access a shell prompt and issue commands with correct syntax</li>\n<li>[ET.2] Use input-output redirection (>, >>, |, 2> , etc.)</li>\n<li>[ET.3] Use grep and regular expressions to analyse text</li>\n<li>[ET.4] Access remote systems using SSH</li>\n<li>[ET.5] Log in and switch users in multiuser targets</li>\n<li>[ET.6] Archive, compress, unpack, and uncompress files using tar, star, gzip, and bzip2</li>\n<li>[ET.7] Create and edit text files</li>\n<li>[ET.8] Create, delete, copy, and move files and directories</li>\n<li>[ET.9] Create hard and soft links</li>\n<li>[ET.10] List, set, and change standard ugo/rwx permissions</li>\n<li>[ET.11] Locate, read, and use system documentation including man, info, and files in /usr/share/doc</li>\n</ul>\n<h1>[ET.1] Access a shell prompt and issue commands with correct syntax</h1>\n<h2>Console</h2>\n<p>The console is where you can receive output from the kernel and type commands to\nthe kernel.  Navigating between consoles is typically done with <code class=\"language-text\">Ctrl+Alt+Fn</code>,\nwhere n is the number of the console and F is one of the function keys.  Virtual\nconsoles are accessed at the physical machine, not remotely.  Graphical\ninstallations typically take place on console 6.</p>\n<h2>Basic commands</h2>\n<p>Here are the most basic commands you will use in day-to-day administration:</p>\n<h3>Navigation and file manipulation</h3>\n<ul>\n<li><code class=\"language-text\">ls</code>: list directory contents</li>\n<li><code class=\"language-text\">cd</code>: change directory</li>\n<li><code class=\"language-text\">rm</code>: remove</li>\n<li><code class=\"language-text\">mv</code>: move</li>\n<li><code class=\"language-text\">cp</code>: copy</li>\n<li><code class=\"language-text\">pwd</code>: print working directory</li>\n<li><code class=\"language-text\">mkdir</code>: make directory</li>\n<li><code class=\"language-text\">touch</code>: make file</li>\n<li><code class=\"language-text\">head</code>: read first 10 lines of file</li>\n<li><code class=\"language-text\">tail</code>: read last 10 lines of file</li>\n<li><code class=\"language-text\">locate</code>: find file</li>\n<li><code class=\"language-text\">grep</code>: search a file</li>\n</ul>\n<h3>Output and user information</h3>\n<ul>\n<li><code class=\"language-text\">echo</code>: write to output </li>\n<li><code class=\"language-text\">id</code>: list user and group IDs</li>\n<li><code class=\"language-text\">date</code>: print the date</li>\n</ul>\n<h3>Manipulating the environment</h3>\n<ul>\n<li><code class=\"language-text\">set</code>: show shell variables</li>\n<li><code class=\"language-text\">alias</code>: create shell alias</li>\n<li><code class=\"language-text\">env</code>: show exported variables (from the parent process)</li>\n<li><code class=\"language-text\">which</code>: show which command from the shell's PATH would run</li>\n<li><code class=\"language-text\">type</code>: show what type of file </li>\n</ul>\n<h1>[ET.2] Use input-output redirection (>, >>, |, 2> , etc.)</h1>\n<p>Inside bash there are three file descriptors: <code class=\"language-text\">STDOUT</code>, <code class=\"language-text\">STDERR</code>,\nand <code class=\"language-text\">STDIN</code>.</p>\n<h2>STDOUT</h2>\n<p>STOUT is represented by file descriptor 1.  You use the redirection operator to\nsend output somewhere else.  <code class=\"language-text\">ls 1&gt;file1.txt</code> sends the output of the command to\nthe file entitled <code class=\"language-text\">file1.txt</code>.</p>\n<h2>STDERR</h2>\n<p>STOUT is represented by file descriptor 2.  You use the redirection operator to\nsend output somewhere else.  <code class=\"language-text\">ls 2&gt;file1.txt</code> sends any errors from running the\ncommand to the file and still sends <code class=\"language-text\">STDOUT</code> to the virtual console.</p>\n<h2>Redirecting both to a file</h2>\n<p>You can reference the address of a redirection file descriptor to send them to\neach other.</p>\n<p>For example, <code class=\"language-text\">2&gt;&amp;1</code> means send anything sent to STDERR is redirected to where STDOUT is\npointing.  Another way of specifying this is to use <code class=\"language-text\">&gt;&amp;</code> which is the same as\nthe previous incantation.</p>\n<p>Keep in mind that STDERR is an unbuffered stream so it writes output\nimmediately.  STDOUT is not so you may want to send each to different files,\nlike so: <code class=\"language-text\">ls &gt;file.txt 2&gt;file-error.txt</code> to avoid output from STDERR to appear\npiecemeal inside STDOUT output.</p>\n<h2>Redirection with >></h2>\n<p>The only difference between <code class=\"language-text\">&gt;</code> and <code class=\"language-text\">&gt;&gt;</code> is that the latter appends and the\nformer overwrites.</p>\n<h2>Piping</h2>\n<p>You can chain command output to other programs using piping.  It's much like\nredirection except the output comes from STDOUT of one program to the STDIN\nof another.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ ls | head\namplifyPublishIgnore.json\ndefault.txt\ngatsby-browser.js\ngatsby-config.js\ngatsby-node.js\ngatsby-ssr.js\nLICENSE\nnode_modules\npackage.json\npackage-lock.json\n$ ls | head | wc -l\n10</code></pre></div>\n<h2>Redirecting to STDIN</h2>\n<p>Using the <code class=\"language-text\">&lt;</code> operator we can send input to a programs.  Keep in mind that\nprograms will not have any metadata about the input.  <code class=\"language-text\">cat &lt; hello.txt</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ touch hello.txt\n$ echo &quot;five&quot; &gt; hello.txt\n$ cat hello.txt\nfive\n$ cat &lt; hello.txt\nfive</code></pre></div>\n<h1>[ET.3] Use grep and regular expressions to analyse text</h1>\n<p>Grep is a very useful tool that can save you hours of writing shell scripts to\nquery results from a shell command.  At it's most basic invocation, it looks\nlike: <code class=\"language-text\">grep PATTERN</code>.</p>\n<p>Assume we have the following file called <code class=\"language-text\">hello.txt</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Very nice to meet you.\n\nHow have you been today.\n\nWhere are you going tomorrow.\n\nHow is the weather.\n\nSee you tomorrow tomorrow</code></pre></div>\n<p>Now, we want to see how many times \"tomorrow\" is written in this file, we can\nuse grep.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ grep tomorrow hello.txt \nWhere are you going tomorrow.\nSee you tomorrow tomorrow\n$ grep -c tomorrow hello.txt \n2</code></pre></div>\n<p>Note that it counts line matches not individual count of the search term.  If\ntomorrow was written twice on one line it would be counted once.</p>\n<h2>Options</h2>\n<p>Here are the most common options you should know.</p>\n<ul>\n<li><code class=\"language-text\">-i</code>: ignore case</li>\n<li><code class=\"language-text\">-c</code>: print count of matching lines</li>\n<li><code class=\"language-text\">-n</code>: print the matching line and its line number</li>\n<li><code class=\"language-text\">-l</code>: print only the file names of files that contain matches</li>\n<li><code class=\"language-text\">-H</code>: print the file name with the matching line (default if grepping multiple\nfiles).</li>\n<li><code class=\"language-text\">-A n</code>: show <code class=\"language-text\">n</code> lines after matching line</li>\n<li><code class=\"language-text\">-B n</code>: show <code class=\"language-text\">n</code> lines before matching line</li>\n<li><code class=\"language-text\">-C n</code>: show <code class=\"language-text\">n</code> lines before and after matching line</li>\n<li><code class=\"language-text\">-v</code>: print lines that don't match the pattern</li>\n</ul>\n<h2>Regular expressions (regexs)</h2>\n<p>Regular expressions can't be covered in detail here and certainly deserve their\nown set of books.  For ease of use I recommend using Perl style regex when using\ngrep: <code class=\"language-text\">grep -P</code>.</p>\n<p>Searching the kernel control ring buffer for all usb references in the 2-2\ndomain.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ dmesg | grep -Pi &#39;.*usb 2-2\\..*&#39; | head -n3\n[107075.519908] usb 2-2.1: new full-speed USB device number 4 using uhci_hcd\n[107075.618612] usb 2-2.1: New USB device found, idVendor=0e0f, idProduct=0004,\nbcdDevice= 1.00\n[107075.618616] usb 2-2.1: New USB device strings: Mfr=1, Product=2,\nSerialNumber=0</code></pre></div>\n<h1>[ET.4] Access remote systems using SSH</h1>\n<p>You'll absolutely need to understand SSH to access your testing environment.\nFortunately, the commands are pretty simple.  Keep in mind OpenSSH comes from\nthe BSD world so the command syntax is different than the GNU tools you're used\nto.</p>\n<h2>Options</h2>\n<p>These are the most common commands I use.</p>\n<ul>\n<li><code class=\"language-text\">-i identify_file</code>: use identity file when connecting</li>\n<li><code class=\"language-text\">-D port</code>: create a SOCKS5 server at specified port and send all incoming\nconnections over to the host</li>\n<li><code class=\"language-text\">-L port:host:hostport</code>: incoming connections on local port be forwarded to\ngiven host and port on the remote side.</li>\n<li><code class=\"language-text\">-p port</code>: port to use when connecting to the remote host.</li>\n<li><code class=\"language-text\">-X</code>: enable X11 forwarding</li>\n</ul>\n<h1>[ET.5] Log in and switch users in multiuser targets</h1>\n<p>SystemD is here and has replaced the init runlevels you may be familiar with.\nInstead, we refer to systemd targets.  Thankfully, the older runlevels can still\nbe referenced if required.</p>\n<h2>Targets</h2>\n<p>Get the default target with <code class=\"language-text\">systemctl get-default</code>.  List current target units\nwith <code class=\"language-text\">systemctl list-units --type target</code>.  Set the default with <code class=\"language-text\">systemctl\nset-default multi-user.target</code>.  Finally, change the current target with\n<code class=\"language-text\">isolate</code>: <code class=\"language-text\">systemctl isolate name.target</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ sudo systemctl get-default\nPassword:\ngraphical.target\n$ sudo systemctl list-units --type target\nUNIT                LOAD   ACTIVE SUB    DESCRIPTION                  \nbasic.target        loaded active active Basic System\ngetty.target        loaded active active Login Prompts\ngraphical.target    loaded active active Graphical Interface\nlocal-fs-pre.target loaded active active Local File Systems (Pre)\nlocal-fs.target     loaded active active Local File Systems\nmachines.target     loaded active active Containers\nmulti-user.target   loaded active active Multi-User System\nnetwork.target      loaded active active Network\nnss-lookup.target   loaded active active Host and Network Name Lookups\npaths.target        loaded active active Paths\nremote-fs.target    loaded active active Remote File Systems\nslices.target       loaded active active Slices\nsockets.target      loaded active active Sockets\nswap.target         loaded active active Swap\nsysinit.target      loaded active active System Initialization\ntime-set.target     loaded active active System Time Set\ntime-sync.target    loaded active active System Time Synchronized\ntimers.target       loaded active active Timers\n\nLOAD   = Reflects whether the unit definition was properly loaded.\nACTIVE = The high-level unit activation state, i.e. generalization of SUB.\nSUB    = The low-level unit activation state, values depend on unit type.\n\n18 loaded units listed. Pass --all to see loaded but inactive units, too.\nTo show all installed unit files use &#39;systemctl list-unit-files&#39;.</code></pre></div>\n<p>The main runlevel targets:</p>\n<ul>\n<li>{poweroff, rescue, multi-user, graphical, reboot}.target}</li>\n<li>You can also use emergency.target: <code class=\"language-text\">systemctl isolate emergency</code> if you can't\neven transition to the rescue runlevel.</li>\n</ul>\n<h2>Switching users</h2>\n<p>Switch users can be done using <code class=\"language-text\">su</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ su john\n$ </code></pre></div>\n<h1>[ET.6] Archive, compress, unpack, and uncompress files using tar, star, gzip, and bzip2</h1>\n<p>The tar command is the default and lauded command to package sets of files and directories together as well as compress them.  The default and preferred compression format is <code class=\"language-text\">bzip2</code>.  It can be used with tar or separately.</p>\n<h2>tar</h2>\n<p>Modern day <code class=\"language-text\">tar</code> has sane defaults and an invocation with <code class=\"language-text\">xf</code> will usually decompress any file it can handle: <code class=\"language-text\">tar xf file</code>.</p>\n<p>More options:</p>\n<ul>\n<li><code class=\"language-text\">c</code>: create.  Usually followed by <code class=\"language-text\">f</code> to indicate the filename of the new tarball.</li>\n<li><code class=\"language-text\">x</code>: extract.</li>\n<li><code class=\"language-text\">a</code>: append</li>\n<li><code class=\"language-text\">d</code>: delete</li>\n<li><code class=\"language-text\">v</code>: verbose</li>\n</ul>\n<h2>bzip2</h2>\n<p>If you receive a bzipped file, you can use bzip2 to decompress them in the current directory - which will result in a file named the same sans the bz2 extension.</p>\n<h1>[ET.7] Create and edit text files</h1>\n<p>Become familiar with vi and ed just in case you are dropped into an emergency\nshell.</p>\n<h1>[ET.8] Create, delete, copy, and move files and directories</h1>\n<p>You can reference ET.1 for some of the basic commands here.  Things to keep in\nmind:</p>\n<ul>\n<li><code class=\"language-text\">mv</code> has a backup command that is non-destructive.  Good for testing moves\nbefore making them part of a shell script.</li>\n<li><code class=\"language-text\">rm</code> has an iteractive mode -- good for checking that recursive deletes won't\nremove anything important</li>\n<li><code class=\"language-text\">rm</code> also has a -d flag which removes empty directories.</li>\n<li><code class=\"language-text\">touch</code> is the default command for creating files.  <code class=\"language-text\">mkdir</code> is the command for\ncreating directories.  You'll often use the -p option on <code class=\"language-text\">mkdir</code> to make a\nnested set of directories.</li>\n</ul>\n<h1>[ET.9] Create hard and soft links</h1>\n<p><code class=\"language-text\">ln</code> is the tool of choice to create links.  <code class=\"language-text\">ln -s</code> creates soft links and\nsimple <code class=\"language-text\">ln</code> creates hard links.  Hard links are essentially the same file so if\nyou delete one you'll delete the other.  Soft links are a reference so you can\ndelete the soft link without removing the target.</p>\n<p>I often get the order mixed up (TARGET vs LINK_NAME) for linking files:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">       ln - make links between files\n\nSYNOPSIS\n       ln [OPTION]... [-T] TARGET LINK_NAME\n       ln [OPTION]... TARGET\n       ln [OPTION]... TARGET... DIRECTORY\n       ln [OPTION]... -t DIRECTORY TARGET...\n\n       ln - make links between files</code></pre></div>\n<p>I fixed that problem by remembering that ln will create the link in the current directory if the link name is not specified.  That way you know that the link name is the 2nd argument.</p>\n<h1>[ET.10] List, set, and change standard ugo/rwx permissions</h1>\n<p>There are a lot of tricks to changing permissions that are much easier than remembering the octals (777, for example).  You can directly reference the target <code class=\"language-text\">ugo</code> for user, group, and other respectively and then use an operator along with the permission to be affected.</p>\n<p>For example, to give the group permissions to read and write, you can issue: <code class=\"language-text\">chmod g+rw</code>.</p>\n<p>Listing permissions is given by <code class=\"language-text\">ls -l</code>.</p>\n<h2>Sticky bit</h2>\n<p>Means that only the owner can delete the file.  Good for <code class=\"language-text\">/tmp</code> directories.</p>\n<h2>SUID/GUID</h2>\n<p>Simply means that when the file in question is executed it will be executed with the permissions of the owner.  Can be checked by looking at <code class=\"language-text\">ls</code> output and seeing the <code class=\"language-text\">s</code> bit set in place of execute.  If it's a capital <code class=\"language-text\">S</code> then the execute bit hasn't been set.</p>\n<h1>[ET.11] Locate, read, and use system documentation including man, info, and files in /usr/share/doc</h1>\n<p>For the exam, my goal is to generally avoid documentation where possible -- simply because I want to know the command well enough to go from memory.  That being said, you may blank of the order of options so I'd generally recommend to get bash-completion installed first and then go to the manpage.</p>\n<h2>Bash completion</h2>\n<p>Can be installed with <code class=\"language-text\">yum install bash-completion</code>.</p>\n<h2>Man pages</h2>\n<p>Man pages can be read with <code class=\"language-text\">man command</code>.  It's split into sections (see <code class=\"language-text\">man man</code>) and you'll probably only need to know sections 1 (executable programs), 5 (file formats), and 8 (system administration commands).</p>\n<h2>Info documents</h2>\n<p>Consider info documents a newer, more comprehensive version of man pages.\nTypically man pages will be enough to understand how to run the program but\nyou'll find that GNU utilities have a very well written info document.  Open\nthem with <code class=\"language-text\">info command</code>.</p>\n<h2>/usr/share/doc</h2>\n<p>Often the <code class=\"language-text\">/usr/share/doc</code> directory contains a lot more details and sample\nconfiguration files.  Keep that in mind if you need to start a service or define\na configuration and you don't know how to get started.  Use grep to find the\nservice/config name and work from there.</p>","frontmatter":{"date":"2019-08-24","updated":null,"path":"/writing/redhat-csa-rhcsa-prep-p2","title":"RHCSA Exam Prep: Part 2: Essential Tools"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}